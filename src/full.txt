Script executed successfully. Result: 
File: script_executor.rs
use crate::conduit::Conduit;
use crate::{executor::DynExecutor, point::Point, spatial_vector::SpatialVector};

use rhai::Dynamic;

pub struct ScriptExecutor;

impl ScriptExecutor {
    pub fn new() -> Self {
        ScriptExecutor {}
    }

    pub fn execute_script(executor: &dyn DynExecutor, script: &str) {
        match executor.dyn_execute(script) {
            Ok(result) => {
                Self::handle_result(result);
            }
            Err(e) => eprintln!("Script execution failed: {:?}", e),
        }
    }

    fn handle_result(result: Dynamic) {
        // Attempt to cast Dynamic to various types and act accordingly

        // Reduce the type name, removing the namespaces, returning the core type
        let simple_type_name = get_simple_type_name(result.type_name());

        // Determine the type from the Dynamic result
        match simple_type_name {
            "Point" => {
                if let Some(point) = result.try_cast::<Point>() {
                    println!(
                        "Script executed successfully. Point length: {}",
                        point.length()
                    );
                } else {
                    println!("Type matched 'Point' but could not be cast.");
                }
            }
            "SpatialVector" => {
                if let Some(vector) = SpatialVector::create_from_dynamic(result) {
                    println!(
                        "Script executed successfully. SpatialVector magnitude: {}, angle: {}",
                        vector.magnitude(),
                        vector.angle()
                    );
                } else {
                    println!("Type matched 'SpatialVector' but could not be cast.");
                }
            }
            "string" => {
                if let Some(string_result) = result.try_cast::<String>() {
                    println!("Script executed successfully. Result: {}", string_result);
                } else {
                    println!("Expected a 'string' but could not cast to a String.");
                }
            }
            // Placeholder for additional types
            _ => println!(
                "Script executed, but the result type '{}' was not recognized.",
                result.type_name()
            ),
        }
    }
}

// Helpers
fn get_simple_type_name(full_type_name: &str) -> &str {
    full_type_name.split("::").last().unwrap_or_default()
}

File: full.txt

File: spatial_vector.rs
use crate::conduit::Conduit;
use crate::executor::EngineConfigurationStrategy;
use rhai::{Dynamic, Engine, FLOAT};
use std::f64::consts::PI;

#[derive(Clone)]
pub struct SpatialVector {
    pub x: FLOAT,
    pub y: FLOAT,
}

impl SpatialVector {
    pub fn new(x: FLOAT, y: FLOAT) -> Self {
        SpatialVector { x, y }
    }

    pub fn magnitude(&self) -> FLOAT {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }

    // Returns the angle in degrees
    pub fn angle(&self) -> FLOAT {
        self.y.atan2(self.x) * 180.0 / PI
    }
}

impl Conduit for SpatialVector {
    fn create_from_dynamic(dynamic: Dynamic) -> Option<Self> {
        dynamic.try_cast::<Self>()
    }
}

pub struct SpatialVectorConfiguration;

impl EngineConfigurationStrategy for SpatialVectorConfiguration {
    fn configure_engine(&self, engine: &mut Engine) {
        engine
            .register_type_with_name::<SpatialVector>("SpatialVector")
            .register_fn("new_spatial_vector", SpatialVector::new)
            .register_get_set(
                "x",
                |v: &mut SpatialVector| v.x,
                |v: &mut SpatialVector, val: FLOAT| v.x = val,
            )
            .register_get_set(
                "y",
                |v: &mut SpatialVector| v.y,
                |v: &mut SpatialVector, val: FLOAT| v.y = val,
            )
            .register_fn("magnitude", SpatialVector::magnitude)
            .register_fn("angle", SpatialVector::angle);
    }
}

File: cat_files.rhai
// cat_files_script.rhai
let directory_path = ".";
let concatenated_contents = cat_files(directory_path);
concatenated_contents

File: create_spatial_vector.rhai
let v = new_spatial_vector(3.0, 4.0);
v


File: executor.rs
use rhai::{Dynamic, Engine, EvalAltResult};

pub trait EngineConfiguration {
    fn configure_engine(&self, engine: &mut Engine);
}

pub trait Executor<T> {
    fn execute(&self, script: &str) -> Result<T, Box<EvalAltResult>>;
}

pub trait DynExecutor {
    fn dyn_execute(&self, script: &str) -> Result<Dynamic, Box<EvalAltResult>>;
}

pub struct BasicExecutor;

impl BasicExecutor {
    pub fn new() -> Self {
        BasicExecutor
    }
}

impl DynExecutor for BasicExecutor {
    fn dyn_execute(&self, script: &str) -> Result<Dynamic, Box<EvalAltResult>> {
        let engine = Engine::new();
        let result = engine.eval::<Dynamic>(script)?;
        Ok(result)
    }
}

pub trait EngineConfigurationStrategy {
    fn configure_engine(&self, engine: &mut Engine);
}

pub struct ConfigurableExecutor {
    configurations: Vec<Box<dyn EngineConfigurationStrategy>>,
}

impl ConfigurableExecutor {
    pub fn new(configurations: Vec<Box<dyn EngineConfigurationStrategy>>) -> Self {
        ConfigurableExecutor { configurations }
    }

    fn configure_engine(&self) -> Engine {
        let mut engine = Engine::new();
        for config in &self.configurations {
            config.configure_engine(&mut engine);
        }
        engine
    }
}

impl DynExecutor for ConfigurableExecutor {
    fn dyn_execute(&self, script: &str) -> Result<Dynamic, Box<EvalAltResult>> {
        let engine = self.configure_engine();
        engine.eval::<Dynamic>(script)
    }
}

File: point.rs
use crate::conduit::Conduit;
use crate::executor::EngineConfigurationStrategy;
use rhai::{Dynamic, Engine, INT};

#[derive(Debug, Clone)]
pub struct Point {
    pub x: INT,
    pub y: INT,
}

impl Point {
    pub fn new(x: INT, y: INT) -> Self {
        Point { x, y }
    }

    pub fn length(&self) -> f64 {
        ((self.x.pow(2) as f64) + (self.y.pow(2) as f64)).sqrt()
    }
}

impl Conduit for Point {
    fn create_from_dynamic(dynamic: Dynamic) -> Option<Self> {
        dynamic.try_cast::<Self>()
    }
}

// pub struct PointConfiguration;

// impl EngineConfiguration for PointConfiguration {
//     fn configure_engine(&self, engine: &mut Engine) {
//         // Configure engine for Point operations
//         engine
//             .register_type_with_name::<Point>("Point")
//             .register_fn("create_point", Point::new)
//             .register_get_set("x", |p: &mut Point| p.x, |p: &mut Point, v: INT| p.x = v)
//             .register_get_set("y", |p: &mut Point| p.y, |p: &mut Point, v: INT| p.y = v)
//             .register_fn("length", Point::length);
//     }
// }

pub struct PointConfiguration;

impl EngineConfigurationStrategy for PointConfiguration {
    fn configure_engine(&self, engine: &mut Engine) {
        engine
            .register_type_with_name::<Point>("Point")
            .register_fn("create_point", Point::new)
            .register_get_set("x", |p: &mut Point| p.x, |p: &mut Point, v: INT| p.x = v)
            .register_get_set("y", |p: &mut Point| p.y, |p: &mut Point, v: INT| p.y = v)
            .register_fn("length", Point::length);
    }
}

File: create_point.rhai
let p = create_point(3, 4);
p.x = 6; 
return p;


File: conduit.rs
use rhai::Dynamic;

pub trait Conduit {
    fn create_from_dynamic(dynamic: Dynamic) -> Option<Self>
    where
        Self: Sized;
}

File: main.rs
#![allow(dead_code)]

use std::env;
use std::fs;

mod conduit;

mod point;
use point::PointConfiguration;

mod spatial_vector;
use spatial_vector::SpatialVectorConfiguration;

mod file_concat;
use file_concat::FileCatConfiguration;

mod script_executor;
use script_executor::ScriptExecutor;

mod executor;
use executor::{ConfigurableExecutor, EngineConfigurationStrategy};

fn main() {
    // Grab the location of RHAI file from CLI args
    // and turn it into the script
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: cargo run <path_to_script.rhai>");
        std::process::exit(1);
    }
    let script_path = &args[1];
    let script = fs::read_to_string(script_path).expect("Failed to read script file");

    // configurations for engine
    let configurations: Vec<Box<dyn EngineConfigurationStrategy>> = vec![
        Box::new(PointConfiguration {}),
        Box::new(SpatialVectorConfiguration {}),
        Box::new(FileCatConfiguration {}),
    ];

    // execute engine on script
    let executor = ConfigurableExecutor::new(configurations);
    ScriptExecutor::execute_script(&executor, &script);
}

File: file_concat.rs
use crate::executor::EngineConfigurationStrategy;

use rhai::{Engine, EvalAltResult};

pub struct FileCatConfiguration;

// impl EngineConfigurationStrategy for FileCatConfiguration {
//     fn configure_engine(&self, engine: &mut Engine) {
//         engine.register_fn(
//             "cat_files",
//             |dir_path: &str| -> Result<String, Box<EvalAltResult>> {
//                 let mut result = String::new();
//                 let paths = std::fs::read_dir(dir_path)
//                     .map_err(|e| format!("Error reading directory: {}", e))?;

//                 for path in paths {
//                     let path = path
//                         .map_err(|e| format!("Error reading path: {}", e))?
//                         .path();
//                     if path.is_file() {
//                         let content = std::fs::read_to_string(&path)
//                             .map_err(|e| format!("Error reading file {:?}: {}", path, e))?;
//                         result.push_str(&content);
//                     }
//                 }
//                 Ok(result)
//             },
//         );
//     }
// }

impl EngineConfigurationStrategy for FileCatConfiguration {
    fn configure_engine(&self, engine: &mut Engine) {
        engine.register_fn(
            "cat_files",
            |dir_path: &str| -> Result<String, Box<EvalAltResult>> {
                let mut result = String::new();
                let paths = std::fs::read_dir(dir_path)
                    .map_err(|e| format!("Error reading directory: {}", e))?;

                for path in paths {
                    let path = path
                        .map_err(|e| format!("Error reading path: {}", e))?
                        .path();
                    if path.is_file() {
                        // Get the file name as a string
                        let file_name = path
                            .file_name()
                            .and_then(|name| name.to_str())
                            .unwrap_or("Unknown File")
                            .to_owned();

                        // Append the file name to the result string
                        result.push_str(&format!("\nFile: {}\n", file_name));

                        let content = std::fs::read_to_string(&path)
                            .map_err(|e| format!("Error reading file {:?}: {}", path, e))?;
                        result.push_str(&content);
                    }
                }
                Ok(result)
            },
        );
    }
}

